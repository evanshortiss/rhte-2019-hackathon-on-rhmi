= RHTE 2019 RHMI Hackathon

Welcome to the RHTE 2019 Red Hat Managed Integration Hackathon! Click the
*Get Started* button to view the hackathon brief and to view specific
requirements.

[type=walkthroughResource,serviceName=openshift]
.Red Hat OpenShift
****
* link:{openshift-host}/console[Console, window="_blank"]
* link:https://help.openshift.com/[Openshift Online Help Center, window="_blank"]
* link:https://blog.openshift.com/[Openshift Blog, window="_blank"]
****

[type=walkthroughResource,serviceName=apicurio]
.Apicurito
****
* link:{apicurio-url}[Console, window="_blank", id="resources-apicurio-url"]
****

[type=walkthroughResource,serviceName=fuse]
.Fuse Online
****
* link:{fuse-url}[Console, window="_blank", id="resources-fuse-url"]
* link:https://access.redhat.com/documentation/en-us/red_hat_fuse/7.3/html/integrating_applications_with_fuse_online/index[Documentation, window="_blank"]
* link:https://www.redhat.com/en/technologies/jboss-middleware/fuse-online[Overview, window="_blank"]
****

[type=walkthroughResource,serviceName=amq-online-standard]
.AMQ Online
****
* link:{enmasse-url}[Console, window="_blank", , id="resources-enmasse-url"]
* link:https://access.redhat.com/documentation/en-us/red_hat_amq/7.4/html/using_amq_online_on_openshift_container_platform/index[Documentation, window="_blank"]
* link:https://www.redhat.com/en/technologies/jboss-middleware/amq[Overview, window="_blank"]
****

[type=walkthroughResource,serviceName=codeready]
.CodeReady Workspaces
****
* link:{che-url}[Console, window="_blank"]
* link:https://developers.redhat.com/products/codeready-workspaces/overview/[Overview, window="_blank"]
* link:https://access.redhat.com/documentation/en-us/red_hat_codeready_workspaces_for_openshift/1.0.0/[Documentation, window="_blank"]
****
[type=walkthroughResource,serviceName=3scale]
.3Scale
****
* link:https://{user-username}-admin.{openshift-app-host}[Console, window="_blank"]
* link:https://access.redhat.com/documentation/en-us/red_hat_3scale_api_management/2.5/[Documentation, window="_blank"]
* link:https://www.redhat.com/en/technologies/jboss-middleware/3scale[Overview, window="_blank"]
****

[time=240]
== Get Hacking

TODO - Place abstract content here.

=== PostgreSQL Details

You've been given access to the customer's PostgreSQL database that was
referenced in the abstract. This contains reference data for all the traffic
junctions and parking meters in the city.

Use the following details to connect:

. Username: `{user-sanitized-username}`
. Password: `Password1`
. Hostname: `postgresql.city-of-losangeles.svc`
. Database: `city-info`
. Port: `5432`

The following tables and permissions are available to you:

. SELECT on junction_info
. SELECT on meter_info
. ALL on junction_status_{user-sanitized-username}
. ALL on meter_status_{user-sanitized-username}

Here are the schemas for each table:

*meter_info*

----
  Column   |  Type   |                        Modifiers                        | Storage  |
-----------+---------+---------------------------------------------------------+----------+
 id        | integer | not null default nextval('meter_info_id_seq'::regclass) | plain    |
 address   | text    | not null                                                | extended |
 latitude  | real    | not null                                                | plain    |
 longitude | real    | not null                                                | plain    |
----

*junction_info*

----
    Column     |  Type   |                         Modifiers                          | Storage  |
---------------+---------+------------------------------------------------------------+----------+
 id            | integer | not null default nextval('junction_info_id_seq'::regclass) | plain    |
 junction_name | text    | not null                                                   | extended |
 latitude      | real    | not null                                                   | plain    |
 longitude     | real    | not null                                                   | plain    |
----

*junction_status_{user-sanitized-username}*

----
    Column   |  Type   |                                  Modifiers                                   | Storage |
-------------+---------+------------------------------------------------------------------------------+---------+
 id          | integer | not null default nextval('junction_status_evals01_id_seq'::regclass)         | plain   |
 junction_id | integer | not null default nextval('junction_status_evals01_junctionid_seq'::regclass) | plain   |
 count_ns    | integer | not null                                                                     | plain   |
 count_ew    | integer | not null                                                                     | plain   |
----

*meter_status_{user-sanitized-username}*

----
   Column    |  Type   |                                 Modifiers                                 | Storage  |
-------------+---------+---------------------------------------------------------------------------+----------+
 id          | integer | not null default nextval('meter_status_evals01_id_seq'::regclass)         | plain    |
 meter_id    | integer | not null default nextval('meter_status_evals01_junctionid_seq'::regclass) | plain    |
 status_text | text    | not null                                                                  | extended |
----

=== Parking & Junction Sensor Data Formats

As described in the abstract, you need to process incoming data from IoT
sensors installed in the city's parking meters and traffic junctions.

This data will be available from AMQ Streams and the data formats are as
follows.

Each parking meter sensor emits a JSON payload like so:

----
{
  // The meter identifier. The meterId corresponds to those in the city's
  // meter_info table in the city-info database
  "meterId": 62,

  // When the payload was sent from this sensor
  "timestamp": 1566432096257,

  // Can be "available", "occupied", "unknown", or "out-of-service"
  "status": "available"
}
----

Each junction has a sensor that detects traffic in north-south and east-west
directions. The JSON payload they send to AMQ Streams looks as follows:

----
{
  // The meter identifier. The junctionId corresponds to those in the city's
  // meter_info table in the city-info database
  "junctionId": 35,

  // When the payload was sent from this sensor
  "timestamp": 1566432096257,

  // How many cars passed east-west and north-south directions at this
  // junction in the last minute
  "counts": {
    "ew": 2,
    "ns": 5
  }
}
----
